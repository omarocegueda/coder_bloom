#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>
#include <set>
#include <random>
#include <sstream>
#include <fstream>

int32_t SolveLinear(const int32_t N, std::vector<int32_t> C, std::vector<int32_t> S) {
  std::sort(C.begin(), C.end());
  std::sort(S.begin(), S.end());
  int32_t candies = 0;
  int32_t i = 0;
  int32_t j = 0;
  while(i<N) {
    while(i<N && S[i]<C[j]) {
      ++i;
    }
    if(i<N) {
      // We know C[j]<=S[i]. Assign it and get a candy
      ++j;
      ++i;
      ++candies;
    } 
  }
  return candies;
}

void WriteCase(const int32_t case_index, const int32_t N, std::vector<int32_t> C, std::vector<int32_t> S, const int32_t sol, std::default_random_engine& engine) {
  shuffle(C.begin(), C.end(), engine);
  shuffle(S.begin(), S.end(), engine);
  // Write input
  {
    std::ostringstream os;
    os<<"case_"<<case_index<<".in";
    std::ofstream F;
    F.open(os.str());
    F<<N<<std::endl;
    for(const int32_t c : C) {
      F << c << " ";
    }
    for(const int32_t s : S) {
      F << s << " ";
    }
    F << std::endl;
    F.close();
  }
  // Write output
  {
    std::ostringstream os;
    os<<"case_"<<case_index<<".out";
    std::ofstream F;
    F.open(os.str());
    F << sol << std::endl;
    F.close();
  }
}

void GenerateCase(const int32_t case_index, const int32_t N, const int32_t k, std::default_random_engine& engine) {
  std::cerr << "Generating case "<< case_index<<std::endl;
  // Generate `k` integers in the middle of the valid range
  const int32_t kMargin = 10*1000;
  const int32_t kBottom = 250 *1000;
  const int32_t kMid =    500 *1000;
  const int32_t kTop =    1000*1000;

  std::uniform_int_distribution<int64_t> uniform_bottom(1, kBottom-kMargin);
  std::uniform_int_distribution<int64_t> uniform_mid(kBottom, kMid-kMargin);
  std::uniform_int_distribution<int64_t> uniform_top(kMid+kMargin, kTop);
  std::uniform_int_distribution<int64_t> uniform_delta(0, kMargin);

  std::vector<int32_t> C(N);
  std::vector<int32_t> S(N);
  for(int i=0; i<k; ++i) {
    C[i] = uniform_mid(engine);
    S[i] = C[i] + uniform_delta(engine);
    // Now S[i] >= C[i] and x < S[i] < y for all x generated by `uniform_bottom`, and y generated by `uniform_top` 
  }
  // Now generate N-k integers for C[:] and corresponding S[:], all of S[:] strictly less than those in C[:] 
  for(int i=k; i<N;++i) {
    C[i] = uniform_top(engine);
    S[i] = uniform_bottom(engine);
  }

  int32_t sol = SolveLinear(N, C, S);
  std::cerr << "N="<<N <<", k="<<k<<", sol="<<sol <<std::endl;
  assert(sol == k);
  WriteCase(case_index, N, C, S, sol, engine); 
}


void GenerateCases() {
  std::random_device rd;
  std::default_random_engine engine(rd());
  GenerateCase(0, 10,      7,      engine);
  GenerateCase(1, 50,      28,     engine);
  GenerateCase(2, 100,     79,     engine);
  GenerateCase(3, 250,     8,      engine);
  GenerateCase(4, 500,     490,    engine);
  GenerateCase(5, 1000,    503,    engine);
  GenerateCase(6, 2000,    21,     engine);
  GenerateCase(7, 10000,   9875,   engine);
  GenerateCase(8, 100000,  58921,  engine);
  GenerateCase(9, 1000000, 682321, engine);
}

void Solve() {
  int32_t N;
  std::cin >> N;
  std::vector<int32_t> C(N);
  std::vector<int32_t> S(N);
  for(int i=0;i<N;++i) {
    std::cin >> C[i];
  }
  for(int i=0;i<N;++i) {
    std::cin >> S[i];
  }
  int32_t sol = SolveLinear(N, C, S);
  std::cout << sol << std::endl;
}

int main() {
  GenerateCases();
  // Solve();
  return 0;
}
